"use client";

import { useState, useMemo, useCallback, useEffect } from "react";
import { BarChart3 } from "lucide-react";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { fetchAllBesoinData, flushBesoins, importBesoinsFromFile } from "@/services/besoin-service";
import { AnalyseService, AnalyseBesoinsResponse } from "@/services/analyse-service";
import { BesoinModel } from "@/model/besoin";
import { CouvertureParBesoin } from "@/model/analyse";
import { ResourcePageLayout } from "@/components/layouts/resource-page-layout";
import { DataTable, DataRow } from "@/components/data-table";
import { useRouter } from "next/navigation";
import { SearchFilter, FilterConfig } from "@/components/filters";

export default function AgendaTest() {
  const router = useRouter();
  const queryClient = useQueryClient();
  
  // √âtats pour les filtres
  const [rechercheText, setRechercheText] = useState("");
  const [filtreEtat, setFiltreEtat] = useState<string>("tous");
  
  // R√©cup√©rer directement les donn√©es besoins depuis le service besoins (SANS analyse automatique)
  const { data: besoinData, isLoading, error, refetch } = useQuery({
    queryKey: ['besoin-data'],
    queryFn: async () => {
      const data = await fetchAllBesoinData();
      return data;
    },
    staleTime: Infinity, // Les donn√©es ne deviennent jamais obsol√®tes automatiquement
    gcTime: 1000 * 60 * 30, // Garder en cache pendant 30 minutes m√™me si pas utilis√©
    refetchOnMount: false, // Ne pas refetch au montage du composant
    refetchOnWindowFocus: false, // Ne pas refetch quand la fen√™tre reprend le focus
    refetchOnReconnect: false, // Ne pas refetch lors de la reconnexion r√©seau
    retry: 1, // R√©essayer seulement 1 fois en cas d'erreur
  });

  // Fonctions pour g√©rer la persistance des donn√©es d'analyse
  const getSavedCouvertureData = (): CouvertureParBesoin[] => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('besoins_couverture_data');
      return saved ? JSON.parse(saved) : [];
    }
    return [];
  };

  const saveCouvertureData = (data: CouvertureParBesoin[]) => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('besoins_couverture_data', JSON.stringify(data));
    }
  };

  // √âtat pour stocker les donn√©es de couverture par besoin (charg√©es manuellement)
  const [couvertureParBesoin, setCouvertureParBesoin] = useState<CouvertureParBesoin[]>([]);
  // √âtat pour l'analyse manuelle
  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false);
  const [analysisError, setAnalysisError] = useState<string>("");
  // √âtat pour les statistiques d'analyse
  const [analysisStats, setAnalysisStats] = useState<AnalyseBesoinsResponse['statistiques'] | null>(null);

  // Effet pour charger les donn√©es sauvegard√©es au montage
  useEffect(() => {
    const savedData = getSavedCouvertureData();
    if (savedData.length > 0) {
      setCouvertureParBesoin(savedData);
    }
  }, []);

  // Fonction pour lancer l'analyse manuellement avec le nouvel endpoint
  const handleAnalysis = useCallback(async () => {
    setIsAnalyzing(true);
    setAnalysisError("");
    
    try {
      console.log("üî¨ [BESOINS] Lancement de l'analyse compl√®te des besoins...");
      
      // Utiliser le nouvel endpoint /analyse/besoins
      const analyseResponse: AnalyseBesoinsResponse = await AnalyseService.analyserTousLesBesoins();
      
      console.log(`üìä [BESOINS] Analyse termin√©e:`, {
        total_besoins: analyseResponse.metadata.total_besoins,
        taux_couverture: analyseResponse.statistiques.taux_couverture,
        date_analyse: analyseResponse.metadata.date_analyse
      });
      
      // Mettre √† jour les donn√©es de besoins avec les √©tats de couverture calcul√©s
      // Invalider le cache pour forcer un nouveau fetch des donn√©es mises √† jour
      await queryClient.invalidateQueries({ queryKey: ['besoin-data'] });
      await refetch();
      
             // Cr√©er des donn√©es de couverture fictives pour maintenir la compatibilit√© avec l'ancien syst√®me
       const couverturesCompatibles: CouvertureParBesoin[] = analyseResponse.besoins.map(besoin => ({
         besoin_id: besoin.id || '',
         quantite: besoin.quantite,
         echeance: besoin.echeance.toISOString(),
         etat_couverture: besoin.etat,
         quantite_disponible: besoin.etat === 'couvert' ? besoin.quantite : 0,
         pourcentage_couverture: besoin.etat === 'couvert' ? 100 : (besoin.etat === 'partiel' ? 50 : 0),
         stock_restant: besoin.etat === 'couvert' ? besoin.quantite : 0
       }));
      
             setCouvertureParBesoin(couverturesCompatibles);
       saveCouvertureData(couverturesCompatibles); // Sauvegarder dans localStorage
       
       // Sauvegarder les statistiques
       setAnalysisStats(analyseResponse.statistiques);
       
       console.log(`‚úÖ [BESOINS] Analyse termin√©e avec ${couverturesCompatibles.length} besoins analys√©s`);
      
    } catch (err) {
      console.error('‚ùå [BESOINS] Erreur lors de l\'analyse:', err);
      setAnalysisError(err instanceof Error ? err.message : 'Erreur lors de l\'analyse');
    } finally {
      setIsAnalyzing(false);
    }
  }, [queryClient, refetch]);




  
  // Fonction pour obtenir l'√©tat de couverture d'un besoin
  const getEtatCouverture = useCallback((besoin: BesoinModel): string => {
    // Si aucune analyse n'a √©t√© faite, utiliser l'√©tat du besoin
    if (couvertureParBesoin.length === 0) {
      return besoin.etat;
    }

    // Logique de recherche de couverture (identique √† avant)
    let couverture = couvertureParBesoin.find(c => c.besoin_id === besoin.id);
    
    if (couverture) {
      return couverture.etat_couverture;
    }
    
    const besoinDate = besoin.echeance.toISOString().split('T')[0];
    couverture = couvertureParBesoin.find(c => {
      const couvertureDate = c.echeance.split('T')[0];
      const dateMatch = couvertureDate === besoinDate;
      const codeMatch = c.besoin_id.includes(besoin.matiere.code_mp);
      const quantiteMatch = Math.abs(c.quantite - besoin.quantite) < 0.01;
      
      return codeMatch && dateMatch && quantiteMatch;
    });
    
    if (couverture) {
      return couverture.etat_couverture;
    }
    
    couverture = couvertureParBesoin.find(c => {
      const couvertureDate = c.echeance.split('T')[0];
      return c.besoin_id.includes(besoin.matiere.code_mp) && couvertureDate === besoinDate;
    });
    
    if (couverture) {
      return couverture.etat_couverture;
    }

    // Si aucune correspondance exacte n'est trouv√©e, retourner l'√©tat original du besoin
    // au lieu d'emprunter l'√©tat d'autres besoins du m√™me code MP
    return besoin.etat;
  }, [couvertureParBesoin]);

  // Fonction pour filtrer les besoins
  const filteredBesoins = useMemo(() => {
    if (!besoinData) return [];
    
    // Filtrage des besoins
    return besoinData.filter((besoin) => {
      const etatCouverture = getEtatCouverture(besoin);
      
      const matchRecherche = rechercheText === "" || 
        besoin.matiere.code_mp.toLowerCase().includes(rechercheText.toLowerCase()) ||
        besoin.matiere.nom.toLowerCase().includes(rechercheText.toLowerCase()) ||
        etatCouverture.toLowerCase().includes(rechercheText.toLowerCase()) ||
        besoin.echeance.toLocaleDateString('fr-FR').includes(rechercheText.toLowerCase());
      
      const matchEtat = filtreEtat === "tous" || etatCouverture === filtreEtat;
      
      return matchRecherche && matchEtat;
    });
  }, [besoinData, rechercheText, filtreEtat, getEtatCouverture]);

  // Pr√©parer les donn√©es pour le DataTable en utilisant les besoins filtr√©s
  const tableData: DataRow[] = useMemo(() => {
    if (!filteredBesoins) return [];
    
    return filteredBesoins.map((besoin: BesoinModel) => {
      const etatCouverture = getEtatCouverture(besoin);
      const couvertureTrouvee = couvertureParBesoin.find(c => c.besoin_id === besoin.id) ||
        couvertureParBesoin.find(c => {
          const besoinDate = besoin.echeance.toISOString().split('T')[0];
          const couvertureDate = c.echeance.split('T')[0];
          return c.besoin_id.includes(besoin.matiere.code_mp) && couvertureDate === besoinDate;
        });
      
      return {
        id: besoin.id,
        code_mp: besoin.matiere.code_mp,
        matiere: besoin.matiere.nom,
        quantite: besoin.quantite,
        echeance: besoin.echeance.toLocaleDateString('fr-FR'),
        echeance_sort: besoin.echeance, // Valeur Date pour le tri
        etat: etatCouverture,
        etat_source: couvertureTrouvee ? 'analyse' : 'besoin',
        // Donn√©es compl√®tes pour les fonctions de rendu
        _besoin: besoin,
        _etat_couverture: etatCouverture
      };
    });
  }, [filteredBesoins, getEtatCouverture, couvertureParBesoin]);

  // Colonnes du tableau avec tri
  const columns = [
    {
      key: 'code_mp',
      label: 'Code MP',
      align: 'left' as const,
      sortable: true,
      sortType: 'string' as const,
      secondarySortKey: 'echeance_sort', // Tri secondaire par √©ch√©ance
      secondarySortType: 'date' as const,
      secondarySortDirection: 'asc' as const // √âch√©ance la plus r√©cente en premier
    },
    {
      key: 'matiere',
      label: 'Mati√®re',
      align: 'left' as const,
      sortable: true,
      sortType: 'string' as const
    },
    {
      key: 'quantite',
      label: 'Quantit√©',
      align: 'right' as const,
      sortable: true,
      sortType: 'number' as const
    },
    {
      key: 'echeance',
      label: '√âch√©ance',
      align: 'left' as const,
      sortable: true,
      sortType: 'date' as const,
      sortKey: 'echeance_sort', // Utiliser la valeur Date pour le tri
      render: (value: unknown) => {
        // Afficher la date format√©e
        return value as string;
      }
    },
    {
      key: 'etat',
      label: '√âtat',
      align: 'left' as const,
      sortable: true,
      sortType: 'string' as const,
      render: (value: unknown, row: DataRow) => {
        const etat = value as string;
        const etatSource = row.etat_source as string;
        
        return (
          <div className="flex items-center gap-1">
            <span className={`px-1 py-0.5 rounded text-xs ${
              etat === 'couvert' ? 'bg-green-100 text-green-800' :
              etat === 'partiel' ? 'bg-yellow-100 text-yellow-800' :
              etat === 'non_couvert' ? 'bg-red-100 text-red-800' :
              'bg-blue-100 text-blue-800'
            }`}>
              {etat}
            </span>
            {etatSource === 'analyse' ? (
              <span className="text-xs text-green-600" title="√âtat calcul√© par l'analyse">
                üìä
              </span>
            ) : (
              <span className="text-xs text-gray-500" title="√âtat du besoin original">
                üìã
              </span>
            )}
          </div>
        );
      }
    },
    {
      key: 'actions',
      label: 'Actions',
      align: 'center' as const,
      sortable: false, // Les actions ne sont pas triables
      render: (value: unknown, row: DataRow) => {
        const besoin = row._besoin as BesoinModel;
        
        return (
          <Button
            size="sm"
            variant="outline"
            onClick={(e) => {
              e.stopPropagation();
              router.push(`/analyses?mp=${encodeURIComponent(besoin.matiere.code_mp)}`);
            }}
            className="flex items-center gap-1 text-xs h-6 px-2"
          >
            <BarChart3 size={12} />
            Analyser
          </Button>
        );
      }
    }
  ];

  // Fonction de rafra√Æchissement personnalis√©e
  const handleRefresh = useCallback(async () => {
    console.log("üîÑ [BESOINS] Rafra√Æchissement manuel des donn√©es...");
    
    // Invalider le cache pour forcer un nouveau fetch
    await queryClient.invalidateQueries({ queryKey: ['besoin-data'] });
    
    // Forcer un nouveau fetch
    await refetch();
    
    // R√©initialiser les donn√©es d'analyse
    setCouvertureParBesoin([]);
    setAnalysisError("");
    setAnalysisStats(null);
    
    console.log("‚úÖ [BESOINS] Donn√©es rafra√Æchies avec succ√®s");
  }, [queryClient, refetch]);

  // Fonction de rafra√Æchissement apr√®s import
  const handleImportSuccess = useCallback(async () => {
    console.log("üì• [BESOINS] Import r√©ussi, rafra√Æchissement des donn√©es...");
    await handleRefresh();
  }, [handleRefresh]);

  // Cr√©er des filtres dynamiques bas√©s sur les donn√©es
  const filterConfigs: FilterConfig[] = useMemo(() => {
    if (!besoinData) return [];
    
    const etatsUniques = [...new Set(besoinData.map(b => b.etat))].filter(Boolean).sort();
    
    return [
      {
        key: "etat",
        label: "√âtat",
        options: etatsUniques.map(e => ({ value: e, label: e }))
      }
    ];
  }, [besoinData]);
  
  const filterValues = {
    etat: filtreEtat
  };
  
  const handleFilterChange = (filterKey: string, value: string) => {
    if (filterKey === "etat") {
      setFiltreEtat(value);
    }
  };



  // Afficher un √©tat de chargement
  if (isLoading) {
    return (
      <div className="space-y-6">
        <LoadingSpinner text="Chargement des donn√©es de besoins..." />
      </div>
    );
  }

  // G√©rer les erreurs
  if (error) {
    return (
      <div className="space-y-6">
        <Alert variant="destructive">
          <AlertTitle>Erreur de chargement</AlertTitle>
          <AlertDescription>
            Impossible de charger les donn√©es de besoins. {error instanceof Error ? error.message : 'Erreur inconnue'}
          </AlertDescription>
        </Alert>
      </div>
    );
  }
  
  // Contenu principal de la page (tableau avec filtres et bouton d'analyse)
  const besoinsContent = (
    <div className="space-y-6">
      {/* Section des filtres */}
      <SearchFilter
        searchValue={rechercheText}
        onSearchChange={setRechercheText}
        searchPlaceholder="Rechercher un besoin..."
        filters={filterConfigs}
        filterValues={filterValues}
        onFilterChange={handleFilterChange}
        onRefresh={handleRefresh}
                 resultCount={filteredBesoins?.length || 0}
        resultLabel="besoin(s) trouv√©(s)"
        isLoading={isLoading}
      />
      
      <div className="bg-white rounded-lg shadow-md p-6">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h2 className="text-xl font-semibold">Liste des Besoins Op√©rationnels</h2>
            <p className="text-gray-600">Vue d√©taill√©e des besoins - cliquez sur &quot;Analyse&quot; pour calculer la couverture</p>
            <p className="text-sm text-blue-600 mt-1">üí° Cliquez sur les en-t√™tes de colonnes pour trier (Code MP, Mati√®re, Quantit√©, √âch√©ance, √âtat)</p>
          </div>
          
          {/* Indicateur d'analyse */}
          {couvertureParBesoin.length > 0 && (
            <div className="text-sm text-green-600 flex items-center gap-2">
              üìä Analyse effectu√©e ({couvertureParBesoin.length} donn√©es de couverture)
              {analysisStats && (
                <span className="ml-2 text-xs bg-green-100 px-2 py-1 rounded">
                  Taux: {analysisStats.taux_couverture.toFixed(1)}% | 
                  Couverts: {analysisStats.couvert} | 
                  Non couverts: {analysisStats.non_couvert}
                </span>
              )}
            </div>
          )}
        </div>
        
        {/* Message d'erreur d'analyse */}
        {analysisError && (
          <Alert variant="destructive" className="mb-4">
            <AlertTitle>Erreur d&apos;analyse</AlertTitle>
            <AlertDescription>{analysisError}</AlertDescription>
          </Alert>
        )}
        
        {tableData && tableData.length > 0 ? (
          <DataTable
            columns={columns}
            data={tableData}
            showAnalysisButton={true}
            onAnalysisClick={handleAnalysis}
            isAnalysisLoading={isAnalyzing}
            analysisButtonLabel="Analyser la couverture"
            defaultSortColumn="echeance"
            defaultSortDirection="asc"
            caption="üí° Cliquez sur le bouton 'Analyser la couverture' pour calculer l'√©tat de couverture de tous les besoins. Cliquez sur les en-t√™tes de colonnes pour trier."
          />
        ) : (
          <p className="text-gray-500">Aucun besoin disponible</p>
        )}
      </div>
    </div>
  );

  return (
    <ResourcePageLayout
      title="Gestion des Besoins Op√©rationnels"
      actions={{
        add: {
          show: true,
          onClick: () => router.push("/besoins/create"),
          label: "Nouveau besoin"
        },
        import: {
          show: true,
          importFunction: importBesoinsFromFile,
          label: "Importer Besoins",
          onSuccess: () => handleImportSuccess()
        },
        flush: {
          show: true,
          flushFunction: flushBesoins,
          confirmMessage: "√ätes-vous s√ªr de vouloir vider tous les besoins ? Cette action est irr√©versible.",
          label: "Vider tous"
        },
        refresh: {
          show: true,
          onRefresh: () => handleRefresh(),
          isLoading: isLoading
        }
      }}
      queryKey={['besoin-data']}
      hasData={!!besoinData && besoinData.length > 0}
      emptyMessage="Aucun besoin disponible"
      emptyDescription="Aucun besoin disponible pour le moment. Importez un fichier CSV pour commencer."
    >
      {besoinsContent}
    </ResourcePageLayout>
  );
} 
